First Problem (372)
class Solution(object):
    def superPow(self, a, b):
        def pow_mod(x, n, mod):
            res = 1
            while n > 0:
                if n % 2 == 1:
                    res = (res * x) % mod
                x = (x * x) % mod
                n //= 2
            return res

        MOD = 1337

        result = 1

        for digit in b:
            result = pow_mod(result, 10, MOD) * pow_mod(a, digit, MOD) % MOD

        return result



#Second Problem (373)
class Solution(object):
    def kSmallestPairs(self, nums1, nums2, k):
        import heapq

        if not nums1 or not nums2 or k == 0:
            return []

        min_heap = []

        for i in range(min(k, len(nums1))):
            heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))

        result = []

        while k > 0 and min_heap:
            sum_val, i, j = heapq.heappop(min_heap)
            result.append([nums1[i], nums2[j]])
            k -= 1

            if j + 1 < len(nums2):
                heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))

        return result




