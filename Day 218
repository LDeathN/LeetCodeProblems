#First Problem (970)
class Solution(object):
    def powerfulIntegers(self, x, y, bound):
        powerful_numbers = set()
    
        i = 0
        while x**i <= bound:
            j = 0
            while x**i + y**j <= bound:
                powerful_numbers.add(x**i + y**j)
                if y == 1:  
                    break
                j += 1
            if x == 1: 
                break
            i += 1
        
        return list(powerful_numbers)



#Second Problem (971)
class Solution(object):
    def flipMatchVoyage(self, root, voyage):
        flipped = []
        index = [0]  

        def dfs(node):
            if not node:
                return True
            if node.val != voyage[index[0]]:
                return False
            
            index[0] += 1
            if node.left and node.left.val != voyage[index[0]]:
                flipped.append(node.val)
                if not dfs(node.right):
                    return False
                if not dfs(node.left):
                    return False
            else:
                if not dfs(node.left):
                    return False
                if not dfs(node.right):
                    return False
            return True

        if dfs(root):
            return flipped
        else:
            return [-1]



#Third Problem (973)
class Solution(object):
    def kClosest(self, points, k):
        points.sort(key=lambda p: p[0]**2 + p[1]**2)
        return points[:k]




