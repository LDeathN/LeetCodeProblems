#First Problem 1041
class Solution(object):
    def isRobotBounded(self, instructions):
        x, y = 0, 0
        dx, dy = 0, 1  

        for instr in instructions:
            if instr == 'G':  
                x, y = x + dx, y + dy
            elif instr == 'L':  
                dx, dy = -dy, dx
            elif instr == 'R':  
                dx, dy = dy, -dx

        return (x == 0 and y == 0) or (dx != 0 or dy != 1)



#Second Problem 1042
class Solution(object):
    def gardenNoAdj(self, n, paths):
        graph = [[] for _ in range(n)]
        for x, y in paths:
            graph[x - 1].append(y - 1)
            graph[y - 1].append(x - 1)
        
        result = [0] * n
        
        for garden in range(n):
            used = {result[neighbor] for neighbor in graph[garden]}
            for flower in range(1, 5):
                if flower not in used:
                    result[garden] = flower
                    break
        
        return result



#Third Problem 1043
class Solution(object):
    def maxSumAfterPartitioning(self, arr, k):
        n = len(arr)
        dp = [0] * (n + 1)
        
        for i in range(1, n + 1):
            max_val = 0
            for j in range(1, min(k, i) + 1):
                max_val = max(max_val, arr[i - j])
                dp[i] = max(dp[i], dp[i - j] + max_val * j)
        
        return dp[n]




