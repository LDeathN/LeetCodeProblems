#First Problem (740)
class Solution(object):
    def deleteAndEarn(self, nums):
        points = Counter(nums)
        max_num = max(nums)
        
        dp = [0] * (max_num + 1)
        
        dp[1] = points[1] * 1  
        
        for x in range(2, max_num + 1):
            dp[x] = max(dp[x - 1], dp[x - 2] + points[x] * x)
        
        return dp[max_num]



#Second Problem (743)
class Solution(object):
    def networkDelayTime(self, times, n, k):
        graph = defaultdict(list)
        for u, v, w in times:
            graph[u].append((v, w))

        dist = [float('inf')] * (n + 1)
        dist[k] = 0
        min_heap = [(0, k)]  

        while min_heap:
            time, u = heapq.heappop(min_heap)
            
            if time > dist[u]:
                continue
            
            for v, w in graph[u]:
                new_time = time + w
                if new_time < dist[v]:
                    dist[v] = new_time
                    heapq.heappush(min_heap, (new_time, v))

        max_time = max(dist[1:]) 
        
        return max_time if max_time != float('inf') else -1




