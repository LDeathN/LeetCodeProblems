#First Problem (740)
class Solution(object):
    def deleteAndEarn(self, nums):
        points = Counter(nums)
        max_num = max(nums)
        
        dp = [0] * (max_num + 1)
        
        dp[1] = points[1] * 1  
        
        for x in range(2, max_num + 1):
            dp[x] = max(dp[x - 1], dp[x - 2] + points[x] * x)
        
        return dp[max_num]



#Second Problem (743)
class Solution(object):
    def networkDelayTime(self, times, n, k):
        graph = defaultdict(list)
        for u, v, w in times:
            graph[u].append((v, w))

        dist = [float('inf')] * (n + 1)
        dist[k] = 0
        min_heap = [(0, k)]  

        while min_heap:
            time, u = heapq.heappop(min_heap)
            
            if time > dist[u]:
                continue
            
            for v, w in graph[u]:
                new_time = time + w
                if new_time < dist[v]:
                    dist[v] = new_time
                    heapq.heappush(min_heap, (new_time, v))

        max_time = max(dist[1:]) 
        
        return max_time if max_time != float('inf') else -1



#Third Problem (752)
class Solution(object):
    def openLock(self, deadends, target):
        dead_set = set(deadends)
        if "0000" in dead_set:
            return -1
        if target == "0000":
            return 0
        
        queue = deque([("0000", 0)])  
        visited = set(["0000"])
        
        def neighbors(state):
            res = []
            for i in range(4):
                digit = int(state[i])
                new_digit_up = (digit + 1) % 10
                res.append(state[:i] + str(new_digit_up) + state[i+1:])
                new_digit_down = (digit - 1 + 10) % 10
                res.append(state[:i] + str(new_digit_down) + state[i+1:])
            return res
        
        while queue:
            current, moves = queue.popleft()
            
            for neighbor in neighbors(current):
                if neighbor == target:
                    return moves + 1
                if neighbor not in dead_set and neighbor not in visited:
                    visited.add(neighbor)
                    queue.append((neighbor, moves + 1))
        
        return -1




